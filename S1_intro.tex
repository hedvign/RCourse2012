\chapter{Introduction}

L'objectif de ce cours est de fournir une introduction générale à R \parencite{R-Development-Core-Team2008}, un langage qui est en train de devenir un standard en analyse de données et calcul scientifique.
R est souvent présenté dans l'optique d'une utilisation pour les statistiques.
Si c'est effectivement une des capacités les plus souvent utilisées de ce langage, ce cours n'abordera pas ce domaine.

L'objectif des 6 séances est de fournir, au travers d'exemples et de mises en application, un apercu suffisament vaste de R pour le rendre utilisable dans la plus grande majorité des situations:
nous aborderons donc les bases du langage, en commençant par les types d'objets utilisés par R, puis consacrerons une partie importante du temps a lire, écrire, et manipuler des jeux de données.
Les dernières séances sont consacrées à la programmation et aux graphiques, qui permettront d'aller plus loin par la suite.

\section{Environnement de travail}

La première étape est de mettre en place notre environnement de travail. Si ce n'est pas déjà fait, commencez par installer R, disponible à \url{http://www.r-project.org/}.

RStudio est un environnement intégré de travail pour R grauit, multi-plateforme, disponible en ligne à \url{http://rstudio.org/}.
La première partie de la séance sera consacrée à l'utilisation de RStudio.  

\section{Types de données}

Cette section présente les types de données comprises par R.
Les langages de programmation stockent en général des variables de différents types d'une manière différente.
Dans les langages de bas niveau, comme C, ces différences peuvent être relativement restrictives, pour, par exemple, convertir un entier en flottant.
R est un langage dit faiblement typé (dans la réalité, R est surtout \emph{très mal} typé, mais c'est un autre problème...), en ce que les valeurs peuvent facilement changer de type.


Il existe deux niveaux d'organisation pour représenter des valeurs dans un format compris par R: les types de données, et les collections de données.
Ce vocabulaire n'est certainement pas le plus précis, mais établit au moins une différence entre les valeurs qu'on veut regrouper dans des structures plus vastes, et ces structures en elles-même.

\subsection{Types de valeurs}

Dans R, stocker n'importe quelle valeur, ou collection de valeur, dans un objet, se fait de la manière suivante:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{objet}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlsymbol{valeur}\mbox{}
\normalfont
\end{flushleft}
\end{kframe}
\end{knitrout}


On peut aussi utiliser indifférement les opérateurs \texttt{<-} ou \texttt{=}.
Ma préférence va au dernier, puisque dans une lecture rapide \texttt{a <- 2} ($a = 2$) ressemble beaucoup (trop) à \texttt{a < -2} ($a < -2$).
Cependant, les recommandations sur la présentation de la syntaxe de R vont dans le sens de l'utilisation de \texttt{<-} (entouré de deux espaces). 

\subsubsection{Numériques}

R est extrèmement performant dans le stockage de nombres, ce qui ne devrait pas surprendre de la part d'un langage dévellopé pour traiter des problèmes statistiques.
Les exemples suivants montrent les difféerentes manières de déclarer un object contenant un nombre:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{a}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlnumber{0.1}\hspace*{\fill}\\
\hlstd{}\hlsymbol{b}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlnumber{1}\hspace*{\fill}\\
\hlstd{}\hlsymbol{c}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlnumber{1e-06}\hspace*{\fill}\\
\hlstd{}\hlsymbol{a}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0.1
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{b}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{c}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1e-06
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Chaînes}

\subsubsection{Booléens}

\subsubsection{Conversions}

\subsection{Collections de valeurs}

\subsubsection{Vecteurs et vectorisation}

Le vecteur est, avec la matrice, l'objet le plus important de R.
R est un langage dit \emph{vectorisé}, c'est-à-dire qui peut traîter plusieurs valeurs regroupées dans un objet unique.
Si on utilise une commande très simple, comme

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlnumber{2}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent on remarque que la sortie est \texttt{[1] 2}.
L'indicateur \texttt{[1]} indique que la valeur retournée est le premier élément d'un vecteur.
La puissance de la notation vectorielle est qu'on peut accéder à une partie du vecteur, avec un \emph{indice}.
Si on prend l'exemple suivant,

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{a}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlnumber{2}\hspace*{\fill}\\
\hlstd{}\hlsymbol{a}\hlkeyword{[}\hlnumber{1}\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{a}\hlkeyword{[}\hlnumber{2}\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent, accéder à la position \texttt{1} \emph{via} l'\emph{indice} \texttt{[1]}, on récupère la première valeur du vecteur \texttt{a}.
Voilà une des particularités de R: tout objet est un vecteur!
Accéder à la position \texttt{[2]} retourne \texttt{NA}, parce que le vecteur \texttt{a} ne possède pas de deuxième position.

On peut créer des vecteurs dans R en utilisant la commande \texttt{c}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{vecteur}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{3}\hlkeyword{,}{\ }\hlnumber{4}\hlkeyword{,}{\ }\hlnumber{5}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\end{kframe}
\end{knitrout}


R propose différents raccourcis pour créer rapidement des vecteurs.
Par exemple, examinez le comportement des commandes suivantes:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{seq}\hlkeyword{(}\hlargument{from}{\ }\hlargument{=}{\ }\hlnumber{0}\hlkeyword{,}{\ }\hlargument{to}{\ }\hlargument{=}{\ }\hlnumber{5}\hlkeyword{,}{\ }\hlargument{by}{\ }\hlargument{=}{\ }\hlnumber{1}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0 1 2 3 4 5
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{seq}\hlkeyword{(}\hlargument{from}{\ }\hlargument{=}{\ }\hlnumber{0}\hlkeyword{,}{\ }\hlargument{to}{\ }\hlargument{=}{\ }\hlnumber{10}\hlkeyword{,}{\ }\hlargument{length}{\ }\hlargument{=}{\ }\hlnumber{3}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1]  0  5 10
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{c}\hlkeyword{(}\hlnumber{0}\hlkeyword{:}\hlnumber{5}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0 1 2 3 4 5
\end{verbatim}
\end{kframe}
\end{knitrout}


L'avantage de la vectorisation est que R va automatiser une grande partie des opérations sur les vecteurs.
Par exemple, examinez l'effet des commandes suivantes:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{a}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{:}\hlnumber{10}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlsymbol{a}\hlkeyword{/}\hlnumber{2}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
##  [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{log}\hlkeyword{(}\hlsymbol{a}\hlkeyword{,}{\ }\hlnumber{10}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
##  [1] 0.0000 0.3010 0.4771 0.6021 0.6990 0.7782 0.8451 0.9031 0.9542 1.0000
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{a}{\ }\hlkeyword{*}{\ }\hlsymbol{a}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
##  [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}
\end{kframe}
\end{knitrout}


Avec les vecteurs vient le concept important de \emph{recyclage}.
Le recyclage consiste a répéter un vecteur autant de fois que nécessaire pour le rendre compatible avec un autre vecteur dans le cadre d'une opération.
Par exemple, les commandes

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{3}\hlkeyword{,}{\ }\hlnumber{4}\hlkeyword{,}{\ }\hlnumber{5}\hlkeyword{)}{\ }\hlkeyword{+}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2 4 4 6 6
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent et

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{3}\hlkeyword{,}{\ }\hlnumber{4}\hlkeyword{,}{\ }\hlnumber{5}\hlkeyword{)}{\ }\hlkeyword{+}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{1}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2 4 4 6 6
\end{verbatim}
\end{kframe}
\end{knitrout}


\noindent sont équivalentes.
Le vecteur \texttt{c(1,2)} du premier exemple est \emph{recyclé} pour atteindre la longueur du premier vecteur.

La taille d'un vecteur est obtenue en utilisant la fonction \texttt{length}:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{length}\hlkeyword{(}\hlnumber{1}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{length}\hlkeyword{(}\hlfunctioncall{c}\hlkeyword{(}\hlnumber{1}\hlkeyword{:}\hlnumber{5}\hlkeyword{)}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 5
\end{verbatim}
\end{kframe}
\end{knitrout}


\textbf{todo} Créer des vecteurs null

\subsubsection{Matrices}

Le type matrice est central dans le fonctionnement de R.
Une fois le principe des vecteurs compris, le fonctionnement des matrices est assez intuitif.
Une matrice est en fait un vecteur a deux dimensions.
Si un vecteur est une ligne, une matrice est une série de lignes et de colonnes.
Dans R, on peut créer une matrice avec la commande \texttt{matrix}, de sorte que

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{matrix}\hlkeyword{(}\hlnumber{0}\hlkeyword{,}{\ }\hlargument{ncol}{\ }\hlargument{=}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlargument{nrow}{\ }\hlargument{=}{\ }\hlnumber{4}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\end{kframe}
\end{knitrout}


\noindent renvoie une matrice pleine de 0, avec 2 colonnes (\texttt{ncol}) et 4 lignes (\texttt{nrow}).

On peut connaître les dimensions d'une matrice de différentes manières:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{dim}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 4 2
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{nrow}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{ncol}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}


Accéder à une position particulière d'une matrice se fait en deux temps.
D'abord, par le numéro de la ligne, ensuite par le numéro de la colonne.
Par exemple, on peut fixer l'élément sur la première ligne, deuxième colonne de \texttt{test\_mat} à 2, avec

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{[}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{]}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlnumber{2}\hspace*{\fill}\\
\hlstd{}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
##      [,1] [,2]
## [1,]    0    2
## [2,]    0    0
## [3,]    0    0
## [4,]    0    0
\end{verbatim}
\end{kframe}
\end{knitrout}


Dans certaines situations, on peut souhaiter avoir accès à une ligne ou une colonne en particulier.
R permet donc de ne spécifier qu'un numéro de ligne, ou un numéro de colonne:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{[}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2 0 0 0
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{[}\hlnumber{1}\hlkeyword{,}{\ }\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0 2
\end{verbatim}
\end{kframe}
\end{knitrout}


Une matrice peut aussi posséder des noms de lignes et de colonnes:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{colnames}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlstring{"{}a"{}}\hlkeyword{,}{\ }\hlstring{"{}b"{}}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlfunctioncall{rownames}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{c}\hlkeyword{(}\hlstring{"{}A"{}}\hlkeyword{,}{\ }\hlstring{"{}B"{}}\hlkeyword{,}{\ }\hlstring{"{}C"{}}\hlkeyword{,}{\ }\hlstring{"{}D"{}}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
##   a b
## A 0 2
## B 0 0
## C 0 0
## D 0 0
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{colnames}\hlkeyword{(}\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] "a" "b"
\end{verbatim}
\end{kframe}
\end{knitrout}


Cela permet aussi d'accéder plus facilement a certaines positions de la matrice:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{[}\hlstring{"{}A"{}}\hlkeyword{,}{\ }\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## a b 
## 0 2 
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{test\usebox{\hlnormalsizeboxunderscore}mat}\hlkeyword{[}\hlstring{"{}A"{}}\hlkeyword{,}{\ }\hlstring{"{}b"{}}\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Listes}

Un des derniers types d'objets qu'il faut connaître est les listes.
Une liste, dans R, est une manière de stocker de l'information venant de source diverses, pour y accéder facilement.
On verra dans la séance~\ref{c:tables} que les listes permettent aussi de traiter très rapidement plusieurs jeux de données à la suite.

Pour créer une liste, on peut utiliser différentes méthodes:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{list}\hlkeyword{(}\hlargument{a}{\ }\hlargument{=}{\ }\hlnumber{1}\hlkeyword{,}{\ }\hlargument{b}{\ }\hlargument{=}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlargument{c}{\ }\hlargument{=}{\ }\hlnumber{3}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
## 
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{u\usebox{\hlnormalsizeboxunderscore}list}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{list}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{3}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlsymbol{u\usebox{\hlnormalsizeboxunderscore}list}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
\end{verbatim}
\end{kframe}
\end{knitrout}


Les listes, comme \texttt{n\_list}, peuvent être nommées:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{names}\hlkeyword{(}\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] "a" "b" "c"
\end{verbatim}
\end{kframe}
\end{knitrout}


On peut accéder aux éléments des listes de différentes manières.
Si la liste est nommée, la notation \texttt{liste\$nom} est possible; dans tous les autres cas, \texttt{liste[[indice]]} fonctionne.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{\usebox{\hlnormalsizeboxdollar}}\hlsymbol{a}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{[[}\hlnumber{1}\hlkeyword{]}\hlkeyword{]}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}


Les listes peuvent être utilisées dans le contexte de la structure \texttt{with}, qui permet d'accéder facilement aux différents éléments.
Pour simplifier, \texttt{with} permet d'éviter d'écrire \texttt{liste\$nom} pour n'écrire que \texttt{nom}; les deux commandes ci-dessous sont donc équivalentes:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{\usebox{\hlnormalsizeboxdollar}}\hlsymbol{a}{\ }\hlkeyword{+}{\ }\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{\usebox{\hlnormalsizeboxdollar}}\hlsymbol{b}{\ }\hlkeyword{-}{\ }\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{\usebox{\hlnormalsizeboxdollar}}\hlsymbol{c}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{with}\hlkeyword{(}\hlsymbol{n\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{,}{\ }\hlkeyword{\usebox{\hlnormalsizeboxopenbrace}}\hspace*{\fill}\\
\hlstd{}{\ }{\ }{\ }{\ }\hlsymbol{a}{\ }\hlkeyword{+}{\ }\hlsymbol{b}{\ }\hlkeyword{-}{\ }\hlsymbol{c}\hspace*{\fill}\\
\hlstd{}\hlkeyword{\usebox{\hlnormalsizeboxclosebrace}}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 0
\end{verbatim}
\end{kframe}
\end{knitrout}


Dans certains cas, il peut être intéréssant d'applatir une liste en un vecteur.
R propose la fonction \texttt{unlist} pour effectuer cette opération:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{flushleft}
\ttfamily\noindent
\hlsymbol{t\usebox{\hlnormalsizeboxunderscore}list}{\ }\hlassignement{\usebox{\hlnormalsizeboxlessthan}-}{\ }\hlfunctioncall{list}\hlkeyword{(}\hlnumber{1}\hlkeyword{,}{\ }\hlnumber{2}\hlkeyword{,}{\ }\hlnumber{3}\hlkeyword{,}{\ }\hlnumber{4}\hlkeyword{,}{\ }\hlnumber{5}\hlkeyword{,}{\ }\hlnumber{6}\hlkeyword{)}\hspace*{\fill}\\
\hlstd{}\hlsymbol{t\usebox{\hlnormalsizeboxunderscore}list}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 4
## 
## [[5]]
## [1] 5
## 
## [[6]]
## [1] 6
## 
\end{verbatim}
\begin{flushleft}
\ttfamily\noindent
\hlfunctioncall{unlist}\hlkeyword{(}\hlsymbol{t\usebox{\hlnormalsizeboxunderscore}list}\hlkeyword{)}\mbox{}
\normalfont
\end{flushleft}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{\emph{Data frames}}

Vu plus en détail dans les autres séances.
