\chapter{Introduction}

L'objectif de ce cours est de fournir une introduction générale à R \parencite{R-Development-Core-Team2008}, un langage qui est en train de devenir un standard en analyse de données et en calcul scientifique.
R est souvent présenté dans l'optique d'une utilisation pour les statistiques.
Si c'est effectivement une des capacités les plus souvent utilisées de ce langage, ce cours n'abordera pas ce domaine.
L'objectif des 6 séances est plutôt de fournir, au travers d'exemples et de mises en application, un apercu suffisament vaste de R pour le rendre utilisable dans la plus grande majorité des situations:
nous aborderons donc les bases du langage, en commençant par les types d'objets utilisés par R, puis consacrerons une partie importante du temps a lire, écrire, et manipuler des jeux de données.
Les dernières séances sont consacrées à la programmation et aux graphiques, qui permettront d'aller plus loin par la suite.

Si R a acquis une très grande popularité dans le milieu de la recherche, c'est parce qu'il permet très facilement de rajouter des fonctionnalités. \emph{via} le système de \emph{packages}.
En écologie et biologie évolutive, les principaux sont \emph{vegan} (analyse de structure des communautés), \emph{simecol} (simulation de systèmes dynamiques), \emph{ape} (analyses phylogénétiques), \emph{bipartite} (analyse des réseaux de pollinisation), et \emph{emdbook} (modèles statistiques).
Chacun de ces \emph{packages} est accompagné d'un livre ou d'une série de publications, et couvrent une variété énorme d'analyses.
Depuis plus récemment, le projet \emph{ROpenSci}\footnote{\url{http://ropensci.org/}} propose des \emph{packages} permettant d'interagir avec les principales bases de données en écologie et évolution, et notamment de réaliser des analyses bibliométriques.
Il est aussi de plus en plus fréquent de voir des articles dans lesquels les auteurs ont écrit un \emph{package} R qui permet de reproduire leurs analyses, ou au moins mis en \emph{supplementary material} des nouvelles fonctions utilisées dans leur travail.  

Le cours s'étend sur 3 jours, et se compose de 6 séances couvrant chacune une demie journée.
L'objectif est qu'à l'issue des 6 séances, vous soyez capables de comprendre le fonctionnement de R (séance 1), de lire, et écrire des données (séance 2), et de les manipuler (séance 3).
La séance 4 comporte une introduction à la programmation, qui vous permettra de réaliser des choses plus poussées.
La séance 5 est consacrée aux graphiques dans R, et couvre les outils de base.
La séance 6 est prévue pour répondre a des questions plus générales.
Chaque séance se déroule en deux temps.
Premièrement, une introduction assez générale des concepts qui seront utilisés, avec des exemples de commandes et leurs résultats.
Deuxièmement, une série de mises en application, qui consistent en un ou plusieurs petits problèmes généraux, mettant en application les notions acquises jusque la. 

\section{Environnement de travail}

La première étape est de mettre en place notre environnement de travail.
Si ce n'est pas déjà fait, commencez par installer R, disponible à \url{http://www.r-project.org/}.
Au lancement de R s'affiche la fenêtre suivante:  

\begin{center}
\includegraphics[width=.7\textwidth]{RConsole}
\end{center}

R n'est donc pas un logiciel comme \emph{JMP}, \emph{Statistica} ou \emph{Excel}.
Sa philosophie est entièrement différente: plutôt que d'utiliser des boutons et des menus, on communique avec R via des commandes, qu'on entre soit directement dans la console, soit dans des fichiers \texttt{.r}.
R est accessible depuis de nombreux autres programmes, incluant \emph{Komodo Edit}\footnote{\url{http://www.sciviews.org/SciViews-K/}}, \emph{Eclipse}\footnote{\url{http://www.walware.de/goto/statet}}, et \emph{NotePad ++}\footnote{\url{http://sourceforge.net/projects/npptor/}}. 

Dans le cadre de ce cours, nous utiliserons \emph{RStudio}. 
\emph{RStudio} est un environnement intégré de travail pour R grauit, multi-plateforme, disponible en ligne à \url{http://rstudio.org/}.
Ce programme permet de réaliser, dans le même environnement, la majorité des tâches qu'on peut vouloir effectuer dans R.

Au lacenemt de \emph{RStudio}, une fenêtre ressemblant à celle ci-dessous s'affice:

\begin{center}
\includegraphics[width=.7\textwidth]{RStudio}
\end{center}

Les difféerentes sections permettent d'avoir accès simultanément à la console R (en bas à gauche), à la fenêtre des scripts (en haut à gauche), à l'historique des dernières commandes, et aux graphiques.
Au cours de la première séance, en même temps que nous découvrirons les bases du langage R, nous survolerons les fonctionnalités de \emph{RStudio}. 

\section{Types de données}

Cette section présente les types de données comprises par R.
Les langages de programmation stockent en général des variables de différents types d'une manière différente.
Dans les langages de bas niveau, comme C, ces différences peuvent être relativement restrictives, pour, par exemple, convertir un entier en flottant.
R est un langage dit faiblement typé (dans la réalité, R est surtout \emph{très mal} typé, mais c'est un autre problème...), en ce que les valeurs peuvent facilement changer de type.


Il existe deux niveaux d'organisation pour représenter des valeurs dans un format compris par R: les types de données, et les collections de données.
Ce vocabulaire n'est certainement pas le plus précis, mais établit au moins une différence entre les valeurs (les données) qu'on veut regrouper dans des structures plus vastes, et ces structures en elles-même (les collections).

\subsection{Types de valeurs}

Dans R, stocker n'importe quelle valeur, ou collection de valeurs, dans un objet, se fait de la manière suivante:

<<eval=FALSE>>=
objet = valeur
@ 

On peut aussi utiliser indifférement les opérateurs \texttt{<-} ou \texttt{=}.
Ma préférence va au dernier, puisque dans une lecture rapide \texttt{a <- 2} ($a = 2$) ressemble beaucoup (trop) à \texttt{a < -2} ($a < -2$).
Cependant, les recommandations sur la présentation de la syntaxe de R vont dans le sens de l'utilisation de \texttt{<-} (entouré de deux espaces), et c'est cette notation qui sera utilisée ici.

\subsubsection{Numériques}

R est extrèmement performant dans le stockage de nombres, ce qui ne devrait pas surprendre de la part d'un langage dévellopé pour traiter des problèmes statistiques.
Les exemples suivants montrent les difféerentes manières de déclarer un object contenant un nombre:

<<>>=
a = 0.1
b = 1
c = 1e-6
a
b
c
@

Pour forcer R a afficher une valeur, on peut utiliser la commande \texttt{print}. Par exemple,

<<demoPrint>>=
print(a)
@

\noindent affichera toujours la valeur contenue dans \texttt{a}.
Cette commande est importante si vous utilisez des fichiers R \emph{via} la commande \texttt{source} (\emph{cf.} séance suivante);
dans ce cas, \texttt{print} est le seul moyen de forcer l'affichage d'une valeur.

\subsubsection{Chaînes}

Les chaînes permettent de stocker des expressions textuelles.
Par exemple,

<<demoString>>=
texte = 'Hello, world!'
texte
@

R permet de manipuler les chaînes, même s'il n'est pas le choix le plus recommandé dans ce domaine (PERL ou Python font un bien meilleur travail).
On peut mentionner quelques commandes simples:

Pour coller plusieurs chaînes entre elles,

<<explPaste>>=
paste('Hello','World!')
paste('Hello','World!',sep=', ')
@

\noindent On peut aussi couper des chaînes sur un motif donné, par exemple, pour connaître l'extension d'un fichier en coupant sur un point:

<<demoStrSplit>>=
filename = 'mon_fichier.dat'
strsplit(filename,'\\.')
strsplit(filename,'_')
@

\noident Le fait d'écrire \texttt{\ \.} et pas simplement \texttt{.} vient du fait que R peut utiliser des expressions régulières pour la découpe des chaînes,
par exemple couper au premier chiffre, et que \texttt{.} a dans ce contexte un sens différent du caractètre \texttt{.}.

\subsubsection{Booléens}

\subsubsection{Conversions}

R est un langage faiblement typé, dans la mesure ou une commande comme

<<>>=
paste(99, 'luftballons', sep='' )
@

\noindent est parfaitement valide.
Pourtant, elle mélange un type numérique avec un type chaîne.

\subsection{Collections de valeurs}

\subsubsection{Vecteurs et vectorisation}

Le vecteur est, avec la matrice, l'objet le plus important de R.
R est un langage dit \emph{vectorisé}, c'est-à-dire qui peut traîter plusieurs valeurs regroupées dans un objet unique.
Si on utilise une commande très simple, comme

<<>>=
2
@

\noindent on remarque que la sortie est \texttt{[1] 2}.
L'indicateur \texttt{[1]} indique que la valeur retournée est le premier élément d'un vecteur.
La puissance de la notation vectorielle est qu'on peut accéder à une partie du vecteur, avec un \emph{indice}.
Si on prend l'exemple suivant,

<<>>=
a = 2
a[1]
a[2]
@

\noindent, accéder à la position \texttt{1} \emph{via} l'\emph{indice} \texttt{[1]}, on récupère la première valeur du vecteur \texttt{a}.
Voilà une des particularités de R: tout objet est un vecteur!
Accéder à la position \texttt{[2]} retourne \texttt{NA}, parce que le vecteur \texttt{a} ne possède pas de deuxième position.

On peut créer des vecteurs dans R en utilisant la commande \texttt{c}.

<<>>=
vecteur = c(1,2,3,4,5)
@

R propose différents raccourcis pour créer rapidement des vecteurs.
Par exemple, examinez le comportement des commandes suivantes:

<<>>=
seq(from=0,to=5,by=1)
seq(from=0,to=10,length=3)
c(0:5)
@

L'avantage de la vectorisation est que R va automatiser une grande partie des opérations sur les vecteurs.
Par exemple, examinez l'effet des commandes suivantes:

<<>>=
a = c(1:10)
a/2
log(a,10)
a*a
@

Avec les vecteurs vient le concept important de \emph{recyclage}.
Le recyclage consiste a répéter un vecteur autant de fois que nécessaire pour le rendre compatible avec un autre vecteur dans le cadre d'une opération.
Par exemple, les commandes

<<>>=
c(1,2,3,4,5) + c(1,2)
@ 

\noindent et

<<>>=
c(1,2,3,4,5) + c(1,2,1,2,1)
@ 

\noindent sont équivalentes.
Le vecteur \texttt{c(1,2)} du premier exemple est \emph{recyclé} pour atteindre la longueur du premier vecteur.

La taille d'un vecteur est obtenue en utilisant la fonction \texttt{length}:

<<>>=
length(1)
length(c(1:5))
@ 

\textbf{todo} Créer des vecteurs null

\subsubsection{Matrices}

Le type matrice est central dans le fonctionnement de R.
Une fois le principe des vecteurs compris, le fonctionnement des matrices est assez intuitif.
Une matrice est en fait un vecteur a deux dimensions.
Si un vecteur est une ligne, une matrice est une série de lignes et de colonnes.
Dans R, on peut créer une matrice avec la commande \texttt{matrix}, de sorte que

<<>>=
test_mat = matrix(0,ncol=2,nrow=4)
@

\noindent renvoie une matrice pleine de 0, avec 2 colonnes (\texttt{ncol}) et 4 lignes (\texttt{nrow}).

On peut connaître les dimensions d'une matrice de différentes manières:
<<>>=
dim(test_mat)
nrow(test_mat)
ncol(test_mat)
@  

Accéder à une position particulière d'une matrice se fait en deux temps.
D'abord, par le numéro de la ligne, ensuite par le numéro de la colonne.
Par exemple, on peut fixer l'élément sur la première ligne, deuxième colonne de \texttt{test\_mat} à 2, avec

<<>>=
test_mat[1,2] = 2
test_mat
@

Dans certaines situations, on peut souhaiter avoir accès à une ligne ou une colonne en particulier.
R permet donc de ne spécifier qu'un numéro de ligne, ou un numéro de colonne:

<<>>=
test_mat[,2]
test_mat[1,]
@

Une matrice peut aussi posséder des noms de lignes et de colonnes:

<<>>=
colnames(test_mat) = c('a','b')
rownames(test_mat) = c('A','B','C','D')
test_mat
colnames(test_mat)
@

Cela permet aussi d'accéder plus facilement a certaines positions de la matrice:

<<>>=
test_mat['A',]
test_mat['A','b']
@

\subsubsection{Listes}

Un des derniers types d'objets qu'il faut connaître est les listes.
Une liste, dans R, est une manière de stocker de l'information venant de source diverses, pour y accéder facilement.
On verra dans la séance~\ref{c:tables} que les listes permettent aussi de traiter très rapidement plusieurs jeux de données à la suite.

Pour créer une liste, on peut utiliser différentes méthodes:

<<>>=
n_list = list(a = 1, b = 2, c = 3)
n_list
u_list = list(1, 2, 3)
u_list
@ 

Les listes, comme \texttt{n\_list}, peuvent être nommées:

<<>>=
names(n_list)
@

On peut accéder aux éléments des listes de différentes manières.
Si la liste est nommée, la notation \texttt{liste\$nom} est possible; dans tous les autres cas, \texttt{liste[[indice]]} fonctionne.

<<>>=
n_list$a
n_list[[1]]
@

Les listes peuvent être utilisées dans le contexte de la structure \texttt{with}, qui permet d'accéder facilement aux différents éléments.
Pour simplifier, \texttt{with} permet d'éviter d'écrire \texttt{liste\$nom} pour n'écrire que \texttt{nom}; les deux commandes ci-dessous sont donc équivalentes:

<<>>=
n_list$a + n_list$b - n_list$c 
with(n_list,{
			a + b - c
		})
@

Dans certains cas, il peut être intéréssant d'applatir une liste en un vecteur.
R propose la fonction \texttt{unlist} pour effectuer cette opération:

<<unlist>>=
t_list = list(1,2,3,4,5,6)
t_list
unlist(t_list)
@

\subsubsection{\emph{Data frames}}

Vu plus en détail dans les autres séances.