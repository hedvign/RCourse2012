% SEANCE 4 : INTROUDCTION A LA PROGRAMMATION
\documentclass[11pt]{paper}
\input{options.tex}

\begin{document}

<<echo=false>>=
options(continue="  ")
options(encoding="utf8")
options(width=60)
@

\title{Introduction à la programmation}
\author{Timothée Poisot}

\maketitle

\begin{abstract}
L'objectif de cette séance est l'initation à la programmation. Les principales structures d'algoritmes et les opérateurs logiques seront abordés.  
\end{abstract}

\tableofcontents\onehalfspacing

\section{Programmer, pourquoi?}

Dans les séances précédentes, nous avons utilisé des fichiers \texttt{.R} pour sauvegarder des listes d'instructions.
Nous avons aussi chargé et manipulé des jeux de données.
Il est souvent nécessaire d'automatiser tout ou partie de ce processus, ce qui implique de faire appel à de la programmation.

L'objectif de cette séance est de

\section{Boucles}

Les boucles permettent parcourir une liste, ou de répéter une série d'instructions, dans des conditions bien définies; c'est une des structures de base de l'algorithmique.
R propose deux types de boucles, les boucles \texttt{for} et les boucles \texttt{while}.
En français, on peut les résumer par ``jusqu'à ce que'' et ``tant que''. 

\subsection{Boucles de type \emph{for}}

Une boucle \texttt{for} permet de répéter un bloc d'instructions un nombre prédéfini de fois, ou d'éxécuter des commandes pour chaque élément d'un tableau de données.
La syntaxe de base est la suivante:

<<>>=
for (step in c(1:10)) cat(step)
@

On peut bien spécifier plusieurs instructions qui doivent être éxécutées à chaque \emph{itération} (étapes de la boucle) en utilisant les accolades:

<<>>=
for (step in c(1:3))
{
	cat(step)
	print(summary(rnorm(100,mean=step)))
}
@

Cette commande affiche le numéro de l'itération en cours (\texttt{cat(step)}), puis affiche les information de base (\texttt{summary}) sur une distribution normale (\texttt{rnorm}) centrée sur \texttt{step}.
Les boucles \texttt{for} peuvent contenir des instructions aussi longues que souhaité.

Une autre application des boucles \texttt{for} est de parcourir un object.
Par exemple, on peut souhaiter, pour chaque élément d'un objet, afficher sa valeur.
R permet de réaliser ce genre d'opérations, avec la syntaxe suivante:

<<>>=
vect =  c('a','b','c','d')
for (val in vect) cat(val)
@ 

Pour chaque élément du vecteur \texttt{vect}, que l'on nomme \texttt{val} pour pouvoir y accéder pendant les itérations, R va afficher la valeur que l'élément contient.

\subsection{Boucles de type \emph{while}}

Les boucles de type \texttt{while}, littéralement \emph{pendant}, permettent de répéter une série d'instructions tant qu'une condition n'a pas été atteinte.
Pour cette raison, il faut bien prendre en compte le fait que mal utilisées, ces boucles peuvent ne jamais stopper.
Il faut donc faire particulièrement attention à la condition qui est évaluée à chaque itération.

Un exemple simple d'utilisation d'une boucle \texttt{while} est le calcul d'une factorielle.
On veut calculer $n!$, ce qui se fait simplement en multipliant l'ensemble des $1\leq k \leq n$.

<<>>=
n = 5
k = n
while(k > 1){
	k = k - 1
	n = n*k
}
print(n)
@ 

On remarquera que dans la parenthèse après \texttt{while} se trouve un test logique; les tests sont abordés dans la partie suivante.

\section{Tests}

\subsection{Expressions conditionnelles}

<<>>=
a = 4
if (a == 4){
	print('yep')
}
@

\subsection{Manipulation des valeurs booléennes}

\section{Fonctions}

\subsection{Généralités}

L'utilisation des fonctions va permettre de gagner du temps dans la programmation.
Comprendre le principe des fonctions dépasse de beaucoup le cadre de R, et mérite qu'on s'y arrête.
Qu'est-ce qu'une fonction? Une série d'instructions qui vont, à partir d'arguments, renvoyer un résultat.
En quoi est-ce différent des scripts que nous avons utilisé jusqu'ici?
Écrire une fonction revient en quelque sorte a `expliquer' le code une fois, et R se charge ensuite de redonner la bonne valeur aux arguments.

Le parallèle le plus évident est celui des fonctions mathématiques: si $f(x) = x^2$, on peut calculer $f(x)$ pour tout $x$, parce qu'on sait quoi faire.
Ça devient donc très avantageux si on doit calculer $f(x)$ un grand nombre de fois.
En écrivant uniquement des scripts, pour calculer la valeur de beaucoup de $x^2$, on aurait écrit:

<<eval=FALSE>>=
1^2
2^2
3^2
4^2
5^2
@

ou encore

<<eval=FALSE>>=
for(i in c(1:5)) i^2
@

Si il faut revenir sur ce code plus tard, et transformer tous les \texttt{\^{}2} en \texttt{\^{}3}, la première solution implique de tout corriger manuellement.
En utilisant une fonction, la logique est différente:

<<>>=
f = function(x) x^2
f(2)
@ 

Peut importe le nombre de fois ou on devra effectuer l'opération contenue dans \texttt{f}, si on veut la modifier, elle sera toujours stockée au même endroit.
Avec cet avantage en tête, quelques généralités sur les fonctions en R.

\subsubsection{Tout est fonction}

Dans la pratique, la majorité des instructions utilisées jusau'à présent sont des fonctions.
Par exemple, \texttt{print}, \texttt{read.table}, et \texttt{apply} sont des fonctions rendues disponibles par R.
%TODO More

\subsubsection{Le \emph{scope}}

Les fonctions existent comme un espace <<à part>> dans R: ce qui se déroule dans une fonction, reste dans une fonction.
Prennons le cas du code suivant:

<<>>=
a = 2
b = 3
f = function(x){
	y = x+a
	z = y
	return(z)
}
f(b)
@

La fonction \texttt{f} peut aller chercher la valeur de \texttt{a} dans l'environnement global, mais tout ce qui est défini au sein de \texttt{f} est innaccessible.
D'ailleurs, tout ce qui est créé dans la fonction est détruit -- retiré de la mémoire -- une fois que la dernière instruction est éxécutée.
Voyez la section sur la fonction \texttt{return} pour plus de détails. Cette notion de quel objet est accessible est extrèmement importante à maîtriser.

\subsection{Déclarer une fonction}

\subsubsection{La commande \emph{return}}

\subsubsection{Arguments}

\section{Mise en application}

\subsection{Test par permutation}

Lorsque les données devient de la normalité, on peut préférer réaliser un test paramétrétique avec des permutations plutôt qu'un test non paramétrique.
La plupart des programmes de statistique n'offrent pas cette possibilité qui demande pourtant très peu d'efforts pour être implémentée dans R.
Dans cette mise en application, on veut effectuer un test t, pour comparer deux distributions, disponibles dans un fichier \texttt{s4-data.txt}.

Le principe d'un test par permutations est simple.
La première étape est d'effectuer le test sur l'échantillon non permuté, pour obtenir la valeur de la statistique ($T$).
Dans le cas du test t, R propose la fonction \texttt{t.test}, et un rapide survol de \texttt{?t.test} vous donnera les arguments nécéssaires et la manière de récupérer la statistique. 
Commencent ensuite les permutations a proprement parler. Pour un nombre $n$ d'itérations choisies (en général 9999), on mélange l'ensemble des valeurs des deux distributions.
On reconstruit ensuite, en tirant au hasard dans le \emph{pool} de valeurs ainsi formées, deux distributions de taille égale.
Cette étape peut, par example, prendre la forme d'une fonction \texttt{resample}, qui prendrait une \texttt{data.frame} avec deux colonnes (la valeur, et le groupe d'origine) en argument.
R propose la fonction \texttt{sample}, qui permettra de mélanger la colonne correspondant au groupe (ce qui recréra automatiquement les deux distributions -- économisons nous!).
Une fois les deux distributions reconstruites, on calcule la nouvelle statistique $T'$.
Si la valeur de $T'$ est inférieure à la valeur de $T$, on incrémente une varaible $N$ de 1.
Sinon, la valeur de $N$ reste la même.

Le calcul de la \emph{p-value} se fait de la manière suivante:

\begin{equation}
	p = \frac{N}{n}
\end{equation}

À partir de ces informations, et des informations données dans l'introduction de cette séance, vous devez être en mesure de programmer sans difficultés une fonction \texttt{t.test.permut}, qui réaliser un test t par permutations.
En bonus, vous pouvez ajouter des arguments qui permettent de contrôler le nombre de permutations qui doivent être réalisées. 

\clearpage
\section{Solution des mises en application}  

\subsection{Test par permutation}



\end{document}
